# Theorem prover

Инструмент для доказательства теорем, основанный на методе резолюции.

## Использование

Загрузите и распакуйте архив с исходным кодом
[последнего релиза](https://github.com/p-senichenkov/theorem-prover/releases/latest) (или
используйте `git clone`).
Запустите с помощью
```bash
python3 main.py
```

Вам будет предложено ввести формулу для доказательства.

Также можно передать формулу как аргумент:
```bash
python3 main.py '((x) -> (y)) & (x) => y'
```
Не забудьте кавычки!

Формулу из файла можно ввести при помощи оболочки:
```bash
python3 main.py <formula.txt
```

### Представление формулы

Формула обычно выглядит так: `(x) -> (y) => (z) & (x)`.
`=>` здесь означает импликацию (следование), которую необходимо доказать (можно также использовать
"штопор": `|-`, см. таблицу ниже).
Такое следование будем называть Импликацией (с большой буквы).
Формула не может содержать больше одной Импликации.
Формула без Импликации доказывается целиком (`x` эквивалентно `=> x`).

`->` обозначает логическую связку "импликация", которая эквивалентна `¬(x) ∨ (y)`.

Операнды любой логической связки должны быть заключены в скобки.

Любой идентификатор, состоящий только из латинских букв, не являющийся ключевым словом -- это
переменная: `x`, `Someone`.

Идентификатор, заключённый в одинарные кавычки -- символьная (вычисляемая при помощи `eval`)
константа: `'3'`, `'"Bob"'`.
Идентификатор, заключённый в двойные кавычки -- строковая константа: `"Bob"`, `"e"`.

Идентификатор, начинающийся с `p_` или `f_` -- "именной" предикат или функция, соответственно:
`p_IsEven`, `f_Increment`.
Такие предикаты и функции не имеют аксиом и определяются только именем.

Внешние конъюнкции могут быть опущены, то есть можно доказывать разделённые пробелами списки
формул:
```
(A) ∨ (B) (C) -> (D) => (A) ↔ (B)
```

Формулы выводятся с использованием большого количества символов Юникода, которые есть не на каждой
клавиатуре.
В таблице перечислены альтернативные представления для всех поддерживаемых операций.
Можно использовать юникодовский символ (например, скопировав из этой таблицы), текстовое
представление или альтернативные символы.
Таким образом, можно использовать любое представление на сером фоне.

| Юникод | Название | Текст | Символы |
| --- | --- | --- | --- |
| `=>` | Импликация | `Implies` | `\|-` |
| `∃` | квантор существования | `exists` | |
| `∀` | квантор всеобщности | `forall` | |
| `¬` | отрицание | `not` | `!` |
| `&` | конъюнкция | `and` | |
| `∨` | дизъюнкция | `or` | `\|` |
| `→` | импликация | `implies` | `->` |
| `↔` | эквивалентность | `equiv` | `<->` |
| `⊕` | исключающее или | `xor` | |
| `↓` | стрелка Пирса | `nor` | |
| `↑` | штрих Шеффера | `nand` | |

Обратите внимание, что `|` означает дизъюнкцию, а не штрих Шеффера.
Это сделано исключительно для удобства: штрих Шеффера используется значительно реже.

Все тонкости разбора формулы можно узнать из регулярных выражений в `lexer.py` и НФБК в `parser.py`.

## Используемый метод и вывод

Используется метод резолюции.
Чтобы доказать формулу необходимо:
1. проотрицать правую часть Импликации;
2. привести формулу к множеству предложений;
3. попытаться вывести из него `nil` (пустое предложение).

Рассмотрим формулу: `(x) -> (y) (!(y)) => (!(x))`.
Вывод для неё будет
```
** Formula transformations **
0. Negate right-hand side:
        &(((x) → (y)) & (¬(y)))   ¬(&(¬(x)))
1. Apply equivalences to get rid of non-trivial logical operations:
        &(((¬(x)) ∨ (y)) & (¬(y)))   ¬(&(¬(x)))
2. Use de-Morgan laws to narrow negation:
        &(((¬(x)) ∨ (y)) & (¬(y)))   ∨(x)
3. Rename bound variables so that all variable names are unique:
        &(((¬(x)) ∨ (y)) & (¬(y)))   ∨(x)
4. Get rid of existence quantifier (use Skolemov constants and functions):
        &(((¬(x)) ∨ (y)) & (¬(y)))   ∨(x)
5. Get rid of universal quantifiers:
        &(((¬(x)) ∨ (y)) & (¬(y)))   ∨(x)
6. Bring formula to CNF:
        ((¬(x)) ∨ (y)) & (¬(y))   ∨(x)
7. Get rid of redundancy:
        ((¬(x)) ∨ (y)) & (¬(y))   x

** Resolution **
 x, ¬(y), (¬(x)) ∨ (y)
--        ------------
\          /
 \        / 
      y
Clauses: ¬(y), y

¬(y),  y
----  --
  \    /
   \  / 
    nil

Formula proved.
```

### Преобразование формулы

Следующие шаги выполняются для приведения формулы к множеству предложений:
0. Отрицание правой части -- Импликация разделяется на левую и правую части; правая часть отрицается.
1. Применение эквивалентностей -- применяются эквивалентности для логических связок так, чтобы
остались только конъюнкция, дизъюнкция и отрицание.
2. Сужение отрицания -- применяются законы де-Моргана и эквивалентности для кванторов для того, чтобы
уменьшить область действия отрицания.
3. Стандартизация имён переменных -- переименование связанных переменных так, чтобы все имена
переменных были уникальны.
4. "Сколемизация" -- кванторы существования заменяются сколемовскими константами и функциями.
5. Удаление кванторов всеобщности -- на этом этапе кванторы всеобщности можно просто не писать.
6. Приведение формулы к КНФ -- применяется дистрибутивность дизъюнкции так, чтобы привести формулу к
конъюнктивной нормальной форме.
7. Удаление избыточности -- различные избыточности удаляются (например, `(x) & (y) & (x)` становится
`x`).

Рекомендуется использовать те же шаги при доказательстве теорем вручную (кроме последнего шага --
это делается неявно в процессе других преобразований).

### Резолюция

Правило резолюции применяется, пока не будет выведено пустое предложение:
```
X ∨ A ∨ Y     Z ∨ ¬A ∨ T
       \       /
        \     /
     X ∨ Y ∨ Z ∨ T
```

Если получилось вывести пустое предложение, то формула доказана.

### Унификация

Общим унификатором называется подстановка `t` вместо свободных вхождений `x` такая, что формулы `A`
и `B` графически равны после подстановки.
Правило резолюции приобретает вид
```
X ∨ F(x) ∨ Y   Z ∨ ¬F(I) ∨ T
          \     /    |I
           \   /     |x
       X ∨ Y ∨ Z ∨ T
```

Константу можно подставлять вместо свободных вхождений переменных; переменную -- вместо сколемовских
констант; что угодно -- вместо сколемовских функций.
